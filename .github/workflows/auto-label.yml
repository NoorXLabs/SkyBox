name: Auto Label

on:
  pull_request_target:
    types: [opened, edited, synchronize, reopened]

permissions:
  pull-requests: write
  issues: write
  contents: read

jobs:
  auto-label:
    runs-on: ubuntu-latest
    steps:
      - name: Apply area labels from changed files
        uses: actions/labeler@v5
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          configuration-path: .github/labeler.yml
          sync-labels: false

      - name: Apply type and triage labels from PR metadata
        uses: actions/github-script@v8
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.payload.pull_request.number;
            const action = context.payload.action;
            const title = (context.payload.pull_request.title || "").trim().toLowerCase();

            const knownTypeLabels = ["type:bug", "type:feature", "type:docs", "type:chore"];
            let derivedType = null;

            if (/^feat(\(.+\))?:/.test(title)) {
              derivedType = "type:feature";
            } else if (/^fix(\(.+\))?:/.test(title)) {
              derivedType = "type:bug";
            } else if (/^docs(\(.+\))?:/.test(title)) {
              derivedType = "type:docs";
            } else if (/^(chore|refactor|test|ci)(\(.+\))?:/.test(title)) {
              derivedType = "type:chore";
            }

            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
              owner,
              repo,
              issue_number,
              per_page: 100
            });

            const currentNames = new Set(currentLabels.map((label) => label.name));

            if (derivedType) {
              for (const label of knownTypeLabels) {
                if (label !== derivedType && currentNames.has(label)) {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number,
                    name: label
                  });
                  currentNames.delete(label);
                }
              }
            }

            const labelsToAdd = [];

            if (derivedType && !currentNames.has(derivedType)) {
              labelsToAdd.push(derivedType);
            }

            const isOpenedOrReopened = action === "opened" || action === "reopened";
            const hasPriority = [...currentNames].some((name) => name.startsWith("priority:"));

            if (isOpenedOrReopened && !hasPriority && !currentNames.has("status:needs-triage")) {
              labelsToAdd.push("status:needs-triage");
            }

            if (labelsToAdd.length > 0) {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number,
                labels: labelsToAdd
              });
            }


# DevBox Up Command Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement `devbox up` command to start development containers with sync verification, editor integration, and devcontainer template scaffolding.

**Architecture:** Command resolves project (arg/cwd/prompt), ensures mutagen sync is running, starts container via devcontainer-cli, then offers to open editor or attach shell. Also adds `devbox editor` command for changing default editor preference.

**Tech Stack:** TypeScript, Commander.js, Inquirer, execa, devcontainer-cli

---

## Task 1: Add Container Module

**Files:**
- Create: `src/lib/container.ts`
- Test: `src/lib/container.test.ts`

**Step 1: Write the failing test**

Create `src/lib/container.test.ts`:

```typescript
// src/lib/container.test.ts
import { describe, expect, test } from "bun:test";
import { getContainerStatus, ContainerStatus } from "./container";

describe("container module", () => {
  test("getContainerStatus returns not_running for non-existent container", async () => {
    const status = await getContainerStatus("/nonexistent/path");
    expect(status).toBe(ContainerStatus.NotRunning);
  });
});
```

**Step 2: Run test to verify it fails**

Run: `bun test src/lib/container.test.ts`
Expected: FAIL with "cannot find module" or similar

**Step 3: Write minimal implementation**

Create `src/lib/container.ts`:

```typescript
// src/lib/container.ts
import { execa } from "execa";

export enum ContainerStatus {
  Running = "running",
  NotRunning = "not_running",
  Error = "error",
}

export async function getContainerStatus(projectPath: string): Promise<ContainerStatus> {
  try {
    const result = await execa("docker", [
      "ps",
      "--filter", `label=devcontainer.local_folder=${projectPath}`,
      "--format", "{{.Status}}",
    ]);

    if (result.stdout.trim()) {
      return ContainerStatus.Running;
    }
    return ContainerStatus.NotRunning;
  } catch {
    return ContainerStatus.Error;
  }
}
```

**Step 4: Run test to verify it passes**

Run: `bun test src/lib/container.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/lib/container.ts src/lib/container.test.ts
git commit -m "feat: add container status detection module"
```

---

## Task 2: Add Container Start/Stop Functions

**Files:**
- Modify: `src/lib/container.ts`
- Modify: `src/lib/container.test.ts`

**Step 1: Write the failing test**

Add to `src/lib/container.test.ts`:

```typescript
import { describe, expect, test } from "bun:test";
import { getContainerStatus, ContainerStatus, startContainer, stopContainer } from "./container";

// ... existing tests ...

describe("startContainer", () => {
  test("startContainer function exists", () => {
    expect(typeof startContainer).toBe("function");
  });
});

describe("stopContainer", () => {
  test("stopContainer function exists", () => {
    expect(typeof stopContainer).toBe("function");
  });
});
```

**Step 2: Run test to verify it fails**

Run: `bun test src/lib/container.test.ts`
Expected: FAIL with "startContainer is not exported"

**Step 3: Write minimal implementation**

Add to `src/lib/container.ts`:

```typescript
export interface ContainerResult {
  success: boolean;
  error?: string;
}

export async function startContainer(
  projectPath: string,
  options?: { rebuild?: boolean }
): Promise<ContainerResult> {
  const args = ["up", "--workspace-folder", projectPath];

  if (options?.rebuild) {
    args.push("--rebuild-if-exists");
  }

  try {
    await execa("devcontainer", args, { stdio: "inherit" });
    return { success: true };
  } catch (err: any) {
    return { success: false, error: err.stderr || err.message };
  }
}

export async function stopContainer(projectPath: string): Promise<ContainerResult> {
  try {
    // Get container ID
    const result = await execa("docker", [
      "ps",
      "-q",
      "--filter", `label=devcontainer.local_folder=${projectPath}`,
    ]);

    const containerId = result.stdout.trim();
    if (!containerId) {
      return { success: true }; // Already stopped
    }

    await execa("docker", ["stop", containerId]);
    return { success: true };
  } catch (err: any) {
    return { success: false, error: err.stderr || err.message };
  }
}
```

**Step 4: Run test to verify it passes**

Run: `bun test src/lib/container.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/lib/container.ts src/lib/container.test.ts
git commit -m "feat: add container start/stop functions"
```

---

## Task 3: Add Editor Opening Function

**Files:**
- Modify: `src/lib/container.ts`
- Modify: `src/lib/container.test.ts`

**Step 1: Write the failing test**

Add to `src/lib/container.test.ts`:

```typescript
import {
  getContainerStatus,
  ContainerStatus,
  startContainer,
  stopContainer,
  openInEditor,
  SUPPORTED_EDITORS
} from "./container";

// ... existing tests ...

describe("editor support", () => {
  test("SUPPORTED_EDITORS contains expected editors", () => {
    expect(SUPPORTED_EDITORS).toContainEqual({ id: "code", name: "VS Code" });
    expect(SUPPORTED_EDITORS).toContainEqual({ id: "cursor", name: "Cursor" });
  });

  test("openInEditor function exists", () => {
    expect(typeof openInEditor).toBe("function");
  });
});
```

**Step 2: Run test to verify it fails**

Run: `bun test src/lib/container.test.ts`
Expected: FAIL with "SUPPORTED_EDITORS is not exported"

**Step 3: Write minimal implementation**

Add to `src/lib/container.ts`:

```typescript
export const SUPPORTED_EDITORS = [
  { id: "code", name: "VS Code" },
  { id: "cursor", name: "Cursor" },
  { id: "code-insiders", name: "VS Code Insiders" },
] as const;

export type EditorId = typeof SUPPORTED_EDITORS[number]["id"] | string;

export async function openInEditor(
  projectPath: string,
  editor: EditorId
): Promise<ContainerResult> {
  try {
    // Try devcontainer open first (works with VS Code)
    if (editor === "code" || editor === "code-insiders") {
      await execa("devcontainer", ["open", "--workspace-folder", projectPath]);
    } else {
      // Direct editor command for others
      await execa(editor, [projectPath]);
    }
    return { success: true };
  } catch (err: any) {
    return { success: false, error: err.stderr || err.message };
  }
}
```

**Step 4: Run test to verify it passes**

Run: `bun test src/lib/container.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/lib/container.ts src/lib/container.test.ts
git commit -m "feat: add editor opening support"
```

---

## Task 4: Add Shell Attach Function

**Files:**
- Modify: `src/lib/container.ts`
- Modify: `src/lib/container.test.ts`

**Step 1: Write the failing test**

Add to `src/lib/container.test.ts`:

```typescript
import {
  // ... existing imports ...
  attachToShell
} from "./container";

// ... existing tests ...

describe("attachToShell", () => {
  test("attachToShell function exists", () => {
    expect(typeof attachToShell).toBe("function");
  });
});
```

**Step 2: Run test to verify it fails**

Run: `bun test src/lib/container.test.ts`
Expected: FAIL with "attachToShell is not exported"

**Step 3: Write minimal implementation**

Add to `src/lib/container.ts`:

```typescript
export async function attachToShell(projectPath: string): Promise<ContainerResult> {
  try {
    await execa("devcontainer", ["exec", "--workspace-folder", projectPath, "/bin/bash"], {
      stdio: "inherit",
    });
    return { success: true };
  } catch (err: any) {
    // Exit code 130 is normal Ctrl+C exit
    if (err.exitCode === 130) {
      return { success: true };
    }
    return { success: false, error: err.stderr || err.message };
  }
}
```

**Step 4: Run test to verify it passes**

Run: `bun test src/lib/container.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/lib/container.ts src/lib/container.test.ts
git commit -m "feat: add shell attach function"
```

---

## Task 5: Add Devcontainer Detection

**Files:**
- Modify: `src/lib/container.ts`
- Modify: `src/lib/container.test.ts`

**Step 1: Write the failing test**

Add to `src/lib/container.test.ts`:

```typescript
import {
  // ... existing imports ...
  hasDevcontainerConfig
} from "./container";
import { mkdirSync, rmSync, writeFileSync, existsSync } from "fs";
import { join } from "path";
import { tmpdir } from "os";

// ... existing tests ...

describe("hasDevcontainerConfig", () => {
  let testDir: string;

  beforeEach(() => {
    testDir = join(tmpdir(), `devbox-container-test-${Date.now()}`);
    mkdirSync(testDir, { recursive: true });
  });

  afterEach(() => {
    if (existsSync(testDir)) {
      rmSync(testDir, { recursive: true });
    }
  });

  test("returns false when no devcontainer.json exists", () => {
    expect(hasDevcontainerConfig(testDir)).toBe(false);
  });

  test("returns true when devcontainer.json exists", () => {
    const devcontainerDir = join(testDir, ".devcontainer");
    mkdirSync(devcontainerDir, { recursive: true });
    writeFileSync(join(devcontainerDir, "devcontainer.json"), "{}");
    expect(hasDevcontainerConfig(testDir)).toBe(true);
  });
});
```

**Step 2: Run test to verify it fails**

Run: `bun test src/lib/container.test.ts`
Expected: FAIL with "hasDevcontainerConfig is not exported"

**Step 3: Write minimal implementation**

Add imports and function to `src/lib/container.ts`:

```typescript
import { existsSync } from "fs";
import { join } from "path";

// ... existing code ...

export function hasDevcontainerConfig(projectPath: string): boolean {
  const configPath = join(projectPath, ".devcontainer", "devcontainer.json");
  const altConfigPath = join(projectPath, ".devcontainer.json");
  return existsSync(configPath) || existsSync(altConfigPath);
}
```

**Step 4: Run test to verify it passes**

Run: `bun test src/lib/container.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/lib/container.ts src/lib/container.test.ts
git commit -m "feat: add devcontainer config detection"
```

---

## Task 6: Add Devcontainer Templates

**Files:**
- Create: `src/lib/templates.ts`
- Test: `src/lib/templates.test.ts`

**Step 1: Write the failing test**

Create `src/lib/templates.test.ts`:

```typescript
// src/lib/templates.test.ts
import { describe, expect, test, beforeEach, afterEach } from "bun:test";
import { mkdirSync, rmSync, existsSync, readFileSync } from "fs";
import { join } from "path";
import { tmpdir } from "os";
import { TEMPLATES, createDevcontainerConfig } from "./templates";

describe("templates", () => {
  let testDir: string;

  beforeEach(() => {
    testDir = join(tmpdir(), `devbox-templates-test-${Date.now()}`);
    mkdirSync(testDir, { recursive: true });
  });

  afterEach(() => {
    if (existsSync(testDir)) {
      rmSync(testDir, { recursive: true });
    }
  });

  test("TEMPLATES contains expected templates", () => {
    expect(TEMPLATES.map(t => t.id)).toContain("node");
    expect(TEMPLATES.map(t => t.id)).toContain("python");
    expect(TEMPLATES.map(t => t.id)).toContain("go");
    expect(TEMPLATES.map(t => t.id)).toContain("generic");
  });

  test("createDevcontainerConfig creates .devcontainer directory", () => {
    createDevcontainerConfig(testDir, "node");
    expect(existsSync(join(testDir, ".devcontainer"))).toBe(true);
    expect(existsSync(join(testDir, ".devcontainer", "devcontainer.json"))).toBe(true);
  });

  test("createDevcontainerConfig writes valid JSON", () => {
    createDevcontainerConfig(testDir, "node");
    const content = readFileSync(join(testDir, ".devcontainer", "devcontainer.json"), "utf-8");
    const parsed = JSON.parse(content);
    expect(parsed.name).toBe("Node.js");
  });
});
```

**Step 2: Run test to verify it fails**

Run: `bun test src/lib/templates.test.ts`
Expected: FAIL with "cannot find module"

**Step 3: Write minimal implementation**

Create `src/lib/templates.ts`:

```typescript
// src/lib/templates.ts
import { mkdirSync, writeFileSync } from "fs";
import { join } from "path";

export interface Template {
  id: string;
  name: string;
  description: string;
  config: object;
}

export const TEMPLATES: Template[] = [
  {
    id: "node",
    name: "Node.js",
    description: "Node.js 20 with npm/yarn",
    config: {
      name: "Node.js",
      image: "mcr.microsoft.com/devcontainers/javascript-node:20",
      postCreateCommand: "npm install",
      customizations: {
        vscode: {
          extensions: ["dbaeumer.vscode-eslint"],
        },
      },
    },
  },
  {
    id: "python",
    name: "Python",
    description: "Python 3.12 with pip/venv",
    config: {
      name: "Python",
      image: "mcr.microsoft.com/devcontainers/python:3.12",
      postCreateCommand: "pip install -r requirements.txt || true",
      customizations: {
        vscode: {
          extensions: ["ms-python.python"],
        },
      },
    },
  },
  {
    id: "go",
    name: "Go",
    description: "Go 1.22",
    config: {
      name: "Go",
      image: "mcr.microsoft.com/devcontainers/go:1.22",
      postCreateCommand: "go mod download || true",
      customizations: {
        vscode: {
          extensions: ["golang.go"],
        },
      },
    },
  },
  {
    id: "generic",
    name: "Generic",
    description: "Debian with basic dev tools",
    config: {
      name: "Development",
      image: "mcr.microsoft.com/devcontainers/base:debian",
      customizations: {
        vscode: {
          extensions: [],
        },
      },
    },
  },
];

export function createDevcontainerConfig(projectPath: string, templateId: string): void {
  const template = TEMPLATES.find((t) => t.id === templateId);
  if (!template) {
    throw new Error(`Unknown template: ${templateId}`);
  }

  const devcontainerDir = join(projectPath, ".devcontainer");
  mkdirSync(devcontainerDir, { recursive: true });

  const configPath = join(devcontainerDir, "devcontainer.json");
  writeFileSync(configPath, JSON.stringify(template.config, null, 2) + "\n");
}
```

**Step 4: Run test to verify it passes**

Run: `bun test src/lib/templates.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/lib/templates.ts src/lib/templates.test.ts
git commit -m "feat: add devcontainer templates"
```

---

## Task 7: Add Project Resolution Helpers

**Files:**
- Create: `src/lib/project.ts`
- Test: `src/lib/project.test.ts`

**Step 1: Write the failing test**

Create `src/lib/project.test.ts`:

```typescript
// src/lib/project.test.ts
import { describe, expect, test, beforeEach, afterEach } from "bun:test";
import { mkdirSync, rmSync, existsSync, writeFileSync } from "fs";
import { join } from "path";
import { tmpdir } from "os";
import { resolveProjectFromCwd, getLocalProjects } from "./project";

describe("project resolution", () => {
  let testDir: string;
  let originalCwd: string;
  let originalEnv: string | undefined;

  beforeEach(() => {
    testDir = join(tmpdir(), `devbox-project-test-${Date.now()}`);
    mkdirSync(testDir, { recursive: true });
    originalCwd = process.cwd();
    originalEnv = process.env.DEVBOX_HOME;
    process.env.DEVBOX_HOME = testDir;
  });

  afterEach(() => {
    process.chdir(originalCwd);
    if (existsSync(testDir)) {
      rmSync(testDir, { recursive: true });
    }
    if (originalEnv) {
      process.env.DEVBOX_HOME = originalEnv;
    } else {
      delete process.env.DEVBOX_HOME;
    }
  });

  test("resolveProjectFromCwd returns null when not in projects dir", () => {
    const result = resolveProjectFromCwd();
    expect(result).toBeNull();
  });

  test("resolveProjectFromCwd returns project name when in project dir", () => {
    const projectsDir = join(testDir, "projects");
    const projectDir = join(projectsDir, "myapp");
    mkdirSync(projectDir, { recursive: true });
    process.chdir(projectDir);

    const result = resolveProjectFromCwd();
    expect(result).toBe("myapp");
  });

  test("getLocalProjects returns empty array when no projects", () => {
    const projects = getLocalProjects();
    expect(projects).toEqual([]);
  });

  test("getLocalProjects returns project names", () => {
    const projectsDir = join(testDir, "projects");
    mkdirSync(join(projectsDir, "app1"), { recursive: true });
    mkdirSync(join(projectsDir, "app2"), { recursive: true });

    const projects = getLocalProjects();
    expect(projects).toContain("app1");
    expect(projects).toContain("app2");
  });
});
```

**Step 2: Run test to verify it fails**

Run: `bun test src/lib/project.test.ts`
Expected: FAIL with "cannot find module"

**Step 3: Write minimal implementation**

Create `src/lib/project.ts`:

```typescript
// src/lib/project.ts
import { existsSync, readdirSync, statSync } from "fs";
import { join, relative, sep } from "path";
import { PROJECTS_DIR } from "./paths";

export function resolveProjectFromCwd(): string | null {
  const cwd = process.cwd();
  const rel = relative(PROJECTS_DIR, cwd);

  // If relative path starts with "..", we're not in PROJECTS_DIR
  if (rel.startsWith("..") || rel === cwd) {
    return null;
  }

  // Get the first directory component (the project name)
  const parts = rel.split(sep);
  return parts[0] || null;
}

export function getLocalProjects(): string[] {
  if (!existsSync(PROJECTS_DIR)) {
    return [];
  }

  return readdirSync(PROJECTS_DIR).filter((entry) => {
    const fullPath = join(PROJECTS_DIR, entry);
    return statSync(fullPath).isDirectory();
  });
}

export function getProjectPath(projectName: string): string {
  return join(PROJECTS_DIR, projectName);
}

export function projectExists(projectName: string): boolean {
  return existsSync(getProjectPath(projectName));
}
```

**Step 4: Run test to verify it passes**

Run: `bun test src/lib/project.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/lib/project.ts src/lib/project.test.ts
git commit -m "feat: add project resolution helpers"
```

---

## Task 8: Update Config Types for Default Editor

**Files:**
- Modify: `src/types/index.ts`

**Step 1: Review current types**

Current `DevboxConfig` has `editor: string` which is used during init.
We need to ensure this can store the default editor preference.

**Step 2: Verify types are already sufficient**

The existing `editor` field in `DevboxConfig` can store the default editor.
No changes needed to types - they already support this.

**Step 3: Commit (skip if no changes)**

No commit needed - types already support default editor storage.

---

## Task 9: Create Up Command - Basic Structure

**Files:**
- Create: `src/commands/up.ts`
- Test: `src/commands/up.test.ts`

**Step 1: Write the failing test**

Create `src/commands/up.test.ts`:

```typescript
// src/commands/up.test.ts
import { describe, expect, test, beforeEach, afterEach } from "bun:test";
import { mkdirSync, rmSync, existsSync, writeFileSync } from "fs";
import { join } from "path";
import { tmpdir } from "os";

describe("up command", () => {
  let testDir: string;
  let originalEnv: string | undefined;

  beforeEach(() => {
    testDir = join(tmpdir(), `devbox-up-test-${Date.now()}`);
    mkdirSync(testDir, { recursive: true });
    originalEnv = process.env.DEVBOX_HOME;
    process.env.DEVBOX_HOME = testDir;
  });

  afterEach(() => {
    if (existsSync(testDir)) {
      rmSync(testDir, { recursive: true });
    }
    if (originalEnv) {
      process.env.DEVBOX_HOME = originalEnv;
    } else {
      delete process.env.DEVBOX_HOME;
    }
  });

  test("project path construction works", () => {
    const projectsDir = join(testDir, "projects");
    const project = "myapp";
    const projectPath = join(projectsDir, project);
    expect(projectPath).toBe(`${testDir}/projects/myapp`);
  });

  test("can detect missing config", () => {
    const configPath = join(testDir, "config.yaml");
    expect(existsSync(configPath)).toBe(false);
  });
});
```

**Step 2: Run test to verify it passes (basic sanity tests)**

Run: `bun test src/commands/up.test.ts`
Expected: PASS

**Step 3: Create up command structure**

Create `src/commands/up.ts`:

```typescript
// src/commands/up.ts
import inquirer from "inquirer";
import { loadConfig, configExists, saveConfig } from "../lib/config";
import { getSyncStatus, resumeSync, waitForSync } from "../lib/mutagen";
import { runRemoteCommand } from "../lib/ssh";
import {
  getContainerStatus,
  ContainerStatus,
  startContainer,
  stopContainer,
  openInEditor,
  attachToShell,
  hasDevcontainerConfig,
  SUPPORTED_EDITORS,
} from "../lib/container";
import { TEMPLATES, createDevcontainerConfig } from "../lib/templates";
import {
  resolveProjectFromCwd,
  getLocalProjects,
  getProjectPath,
  projectExists,
} from "../lib/project";
import { success, error, info, header, warn, spinner } from "../lib/ui";

interface UpOptions {
  editor?: boolean;
  attach?: boolean;
  rebuild?: boolean;
  noPrompt?: boolean;
  verbose?: boolean;
}

export async function upCommand(
  projectArg: string | undefined,
  options: UpOptions
): Promise<void> {
  // Step 1: Check config exists
  if (!configExists()) {
    error("devbox not configured. Run 'devbox init' first.");
    process.exit(1);
  }

  const config = loadConfig();
  if (!config) {
    error("Failed to load config.");
    process.exit(1);
  }

  // Step 2: Resolve project
  let project = projectArg;

  if (!project) {
    // Try to detect from current directory
    project = resolveProjectFromCwd();
  }

  if (!project) {
    // Prompt for project selection
    const projects = getLocalProjects();

    if (projects.length === 0) {
      error("No local projects found. Run 'devbox clone' or 'devbox push' first.");
      process.exit(1);
    }

    if (options.noPrompt) {
      error("No project specified and --no-prompt is set.");
      process.exit(1);
    }

    const { selectedProject } = await inquirer.prompt([
      {
        type: "list",
        name: "selectedProject",
        message: "Select a project:",
        choices: projects,
      },
    ]);
    project = selectedProject;
  }

  // Verify project exists locally
  if (!projectExists(project)) {
    error(`Project '${project}' not found locally. Run 'devbox clone ${project}' first.`);
    process.exit(1);
  }

  const projectPath = getProjectPath(project);
  header(`Starting '${project}'...`);

  // Step 3: Ensure sync is running
  const syncSpin = spinner("Checking sync status...");
  const syncStatus = await getSyncStatus(project);

  if (!syncStatus.exists) {
    syncSpin.fail("No sync session found");
    error(`No sync session for '${project}'. Run 'devbox clone ${project}' first.`);
    process.exit(1);
  }

  if (syncStatus.paused) {
    syncSpin.text = "Resuming sync...";
    const resumeResult = await resumeSync(project);
    if (!resumeResult.success) {
      syncSpin.fail("Failed to resume sync");
      error(resumeResult.error || "Unknown error");
      process.exit(1);
    }
    syncSpin.succeed("Sync resumed");
  } else {
    syncSpin.succeed("Sync is active");
  }

  // Step 4: Check container status
  const containerStatus = await getContainerStatus(projectPath);

  if (containerStatus === ContainerStatus.Running) {
    if (options.noPrompt) {
      info("Container already running, continuing...");
    } else {
      const { restart } = await inquirer.prompt([
        {
          type: "confirm",
          name: "restart",
          message: "Container already running. Restart it?",
          default: false,
        },
      ]);

      if (restart) {
        const stopSpin = spinner("Stopping container...");
        const stopResult = await stopContainer(projectPath);
        if (!stopResult.success) {
          stopSpin.fail("Failed to stop container");
          error(stopResult.error || "Unknown error");
          process.exit(1);
        }
        stopSpin.succeed("Container stopped");
      } else {
        // Skip to post-start options
        await handlePostStart(projectPath, config, options);
        return;
      }
    }
  }

  // Step 5: Check for devcontainer.json
  if (!hasDevcontainerConfig(projectPath)) {
    // Check remote first
    const remoteSpin = spinner("Checking remote for devcontainer config...");
    const remoteHasConfig = await checkRemoteDevcontainer(
      config.remote.host,
      config.remote.base_path,
      project
    );

    if (remoteHasConfig) {
      remoteSpin.text = "Found on remote, syncing...";
      await waitForSync(project);
      remoteSpin.succeed("Synced devcontainer config from remote");
    } else {
      remoteSpin.warn("No devcontainer.json found");

      if (options.noPrompt) {
        error("No devcontainer.json found and --no-prompt is set.");
        process.exit(1);
      }

      // Offer to create template
      const { createTemplate } = await inquirer.prompt([
        {
          type: "confirm",
          name: "createTemplate",
          message: "No devcontainer.json found. Would you like to create one?",
          default: true,
        },
      ]);

      if (!createTemplate) {
        info("Please add a .devcontainer/devcontainer.json and try again.");
        return;
      }

      const { templateId } = await inquirer.prompt([
        {
          type: "list",
          name: "templateId",
          message: "Select a template:",
          choices: TEMPLATES.map((t) => ({
            name: `${t.name} - ${t.description}`,
            value: t.id,
          })),
        },
      ]);

      createDevcontainerConfig(projectPath, templateId);
      success("Created .devcontainer/devcontainer.json");

      // Commit the new config
      await commitDevcontainerConfig(projectPath);
    }
  }

  // Step 6: Start container with retry
  await startContainerWithRetry(projectPath, options);

  // Step 7: Post-start options
  await handlePostStart(projectPath, config, options);
}

async function checkRemoteDevcontainer(
  host: string,
  basePath: string,
  project: string
): Promise<boolean> {
  const result = await runRemoteCommand(
    host,
    `test -f ${basePath}/${project}/.devcontainer/devcontainer.json && echo "EXISTS" || echo "NOT_FOUND"`
  );
  return result.stdout?.includes("EXISTS") ?? false;
}

async function commitDevcontainerConfig(projectPath: string): Promise<void> {
  try {
    const { execa } = await import("execa");
    await execa("git", ["-C", projectPath, "add", ".devcontainer/devcontainer.json"]);
    await execa("git", ["-C", projectPath, "commit", "-m", "Add devcontainer configuration"]);
    info("Committed devcontainer.json to git");
  } catch {
    // Git commit might fail if no changes or not a git repo - that's ok
  }
}

async function startContainerWithRetry(
  projectPath: string,
  options: UpOptions
): Promise<void> {
  const startSpin = spinner("Starting container...");

  let result = await startContainer(projectPath, { rebuild: options.rebuild });

  if (!result.success) {
    startSpin.text = "Container failed, retrying...";
    result = await startContainer(projectPath, { rebuild: true });

    if (!result.success) {
      startSpin.fail("Container failed to start");
      error(result.error || "Unknown error");
      if (options.verbose) {
        console.log("\nFull error output:");
        console.log(result.error);
      } else {
        info("Run with --verbose for full logs.");
      }
      process.exit(1);
    }
  }

  startSpin.succeed("Container started");
}

async function handlePostStart(
  projectPath: string,
  config: any,
  options: UpOptions
): Promise<void> {
  // Handle flags for non-interactive mode
  if (options.editor && options.attach) {
    const editor = config.editor || "code";
    await openInEditor(projectPath, editor);
    await attachToShell(projectPath);
    return;
  }

  if (options.editor) {
    const editor = config.editor || "code";
    await openInEditor(projectPath, editor);
    return;
  }

  if (options.attach) {
    await attachToShell(projectPath);
    return;
  }

  if (options.noPrompt) {
    success("Container ready.");
    return;
  }

  // Interactive mode - check if we need to ask for editor preference
  let editor = config.editor;

  if (!editor) {
    const { selectedEditor } = await inquirer.prompt([
      {
        type: "list",
        name: "selectedEditor",
        message: "Which editor would you like to use?",
        choices: [
          ...SUPPORTED_EDITORS.map((e) => ({ name: e.name, value: e.id })),
          { name: "Other (specify command)", value: "other" },
        ],
      },
    ]);

    if (selectedEditor === "other") {
      const { customEditor } = await inquirer.prompt([
        {
          type: "input",
          name: "customEditor",
          message: "Enter editor command:",
        },
      ]);
      editor = customEditor;
    } else {
      editor = selectedEditor;
    }

    const { makeDefault } = await inquirer.prompt([
      {
        type: "confirm",
        name: "makeDefault",
        message: `Make ${editor} your default editor for future sessions?`,
        default: true,
      },
    ]);

    if (makeDefault) {
      config.editor = editor;
      saveConfig(config);
      success(`Set ${editor} as default editor.`);
    }
  }

  // Ask what to do
  const { action } = await inquirer.prompt([
    {
      type: "list",
      name: "action",
      message: "What would you like to do?",
      choices: [
        { name: "Open in editor", value: "editor" },
        { name: "Attach to shell", value: "shell" },
        { name: "Both", value: "both" },
        { name: "Neither (just exit)", value: "none" },
      ],
    },
  ]);

  if (action === "editor" || action === "both") {
    const openSpin = spinner(`Opening in ${editor}...`);
    const openResult = await openInEditor(projectPath, editor);
    if (openResult.success) {
      openSpin.succeed(`Opened in ${editor}`);
    } else {
      openSpin.fail(`Failed to open in ${editor}`);
      warn(openResult.error || "Unknown error");
    }
  }

  if (action === "shell" || action === "both") {
    info("Attaching to shell (Ctrl+D to exit)...");
    await attachToShell(projectPath);
  }

  if (action === "none") {
    success("Container ready. Run 'devbox up' again to open editor or attach.");
  }
}
```

**Step 4: Run tests**

Run: `bun test src/commands/up.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/commands/up.ts src/commands/up.test.ts
git commit -m "feat: add devbox up command"
```

---

## Task 10: Create Editor Command

**Files:**
- Create: `src/commands/editor.ts`
- Test: `src/commands/editor.test.ts`

**Step 1: Write the failing test**

Create `src/commands/editor.test.ts`:

```typescript
// src/commands/editor.test.ts
import { describe, expect, test, beforeEach, afterEach } from "bun:test";
import { mkdirSync, rmSync, existsSync, writeFileSync, readFileSync } from "fs";
import { join } from "path";
import { tmpdir } from "os";
import { stringify, parse } from "yaml";

describe("editor command", () => {
  let testDir: string;
  let originalEnv: string | undefined;

  beforeEach(() => {
    testDir = join(tmpdir(), `devbox-editor-test-${Date.now()}`);
    mkdirSync(testDir, { recursive: true });
    originalEnv = process.env.DEVBOX_HOME;
    process.env.DEVBOX_HOME = testDir;
  });

  afterEach(() => {
    if (existsSync(testDir)) {
      rmSync(testDir, { recursive: true });
    }
    if (originalEnv) {
      process.env.DEVBOX_HOME = originalEnv;
    } else {
      delete process.env.DEVBOX_HOME;
    }
  });

  test("can read editor from config", () => {
    const config = {
      remote: { host: "myserver", base_path: "~/code" },
      editor: "cursor",
      defaults: { sync_mode: "two-way-resolved", ignore: [] },
      projects: {},
    };
    const configPath = join(testDir, "config.yaml");
    writeFileSync(configPath, stringify(config));

    const content = readFileSync(configPath, "utf-8");
    const parsed = parse(content);
    expect(parsed.editor).toBe("cursor");
  });

  test("can update editor in config", () => {
    const config = {
      remote: { host: "myserver", base_path: "~/code" },
      editor: "code",
      defaults: { sync_mode: "two-way-resolved", ignore: [] },
      projects: {},
    };
    const configPath = join(testDir, "config.yaml");
    writeFileSync(configPath, stringify(config));

    // Update editor
    const parsed = parse(readFileSync(configPath, "utf-8"));
    parsed.editor = "cursor";
    writeFileSync(configPath, stringify(parsed));

    const updated = parse(readFileSync(configPath, "utf-8"));
    expect(updated.editor).toBe("cursor");
  });
});
```

**Step 2: Run test to verify it passes**

Run: `bun test src/commands/editor.test.ts`
Expected: PASS

**Step 3: Create editor command**

Create `src/commands/editor.ts`:

```typescript
// src/commands/editor.ts
import inquirer from "inquirer";
import { loadConfig, configExists, saveConfig } from "../lib/config";
import { SUPPORTED_EDITORS } from "../lib/container";
import { success, error, info, header } from "../lib/ui";

export async function editorCommand(): Promise<void> {
  if (!configExists()) {
    error("devbox not configured. Run 'devbox init' first.");
    process.exit(1);
  }

  const config = loadConfig();
  if (!config) {
    error("Failed to load config.");
    process.exit(1);
  }

  const currentEditor = config.editor || "not set";
  header("Editor Configuration");
  info(`Current default: ${currentEditor}`);
  console.log();

  const choices = SUPPORTED_EDITORS.map((e) => ({
    name: e.id === config.editor ? `${e.name} (current)` : e.name,
    value: e.id,
  }));
  choices.push({ name: "Other (specify command)", value: "other" });

  const { selectedEditor } = await inquirer.prompt([
    {
      type: "list",
      name: "selectedEditor",
      message: "Select default editor:",
      choices,
    },
  ]);

  let editor = selectedEditor;

  if (selectedEditor === "other") {
    const { customEditor } = await inquirer.prompt([
      {
        type: "input",
        name: "customEditor",
        message: "Enter editor command:",
      },
    ]);
    editor = customEditor;
  }

  if (editor === config.editor) {
    info("Editor unchanged.");
    return;
  }

  config.editor = editor;
  saveConfig(config);
  success(`Default editor updated to ${editor}.`);
}
```

**Step 4: Run tests**

Run: `bun test src/commands/editor.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/commands/editor.ts src/commands/editor.test.ts
git commit -m "feat: add devbox editor command"
```

---

## Task 11: Register Commands in CLI

**Files:**
- Modify: `src/index.ts`

**Step 1: Update CLI entry point**

Edit `src/index.ts` to add the new commands:

```typescript
// src/index.ts
import { program } from "commander";
import { initCommand } from "./commands/init";
import { browseCommand } from "./commands/browse";
import { listCommand } from "./commands/list";
import { cloneCommand } from "./commands/clone";
import { pushCommand } from "./commands/push";
import { upCommand } from "./commands/up";
import { editorCommand } from "./commands/editor";

program
  .name("devbox")
  .description("Local-first dev containers with remote sync")
  .version("0.1.0");

program
  .command("init")
  .description("Interactive setup wizard")
  .action(initCommand);

program
  .command("browse")
  .description("List projects on remote server")
  .action(browseCommand);

program
  .command("list")
  .description("List local projects")
  .action(listCommand);

program
  .command("clone <project>")
  .description("Clone remote project locally")
  .action(cloneCommand);

program
  .command("push <path> [name]")
  .description("Push local project to remote")
  .action(pushCommand);

program
  .command("up [project]")
  .description("Start a development container")
  .option("-e, --editor", "Open in editor after start")
  .option("-a, --attach", "Attach to shell after start")
  .option("-r, --rebuild", "Force container rebuild")
  .option("--no-prompt", "Non-interactive mode")
  .option("-v, --verbose", "Show detailed output")
  .action(upCommand);

program
  .command("editor")
  .description("Change default editor")
  .action(editorCommand);

program.parse();
```

**Step 2: Run all tests**

Run: `bun test`
Expected: All tests PASS

**Step 3: Commit**

```bash
git add src/index.ts
git commit -m "feat: register up and editor commands in CLI"
```

---

## Task 12: Manual Integration Test

**Step 1: Build and test CLI**

```bash
bun run src/index.ts --help
bun run src/index.ts up --help
bun run src/index.ts editor --help
```

Expected: Help output shows new commands with options

**Step 2: Verify commands are accessible**

```bash
bun run src/index.ts up --help
```

Expected output should include:
- `-e, --editor` option
- `-a, --attach` option
- `-r, --rebuild` option
- `--no-prompt` option
- `-v, --verbose` option

**Step 3: Final commit if any fixes needed**

```bash
git status
# If clean, we're done
# If changes needed, commit them
```

---

## Summary

This plan implements:

1. **Container module** (`src/lib/container.ts`) - Status detection, start/stop, editor opening, shell attach
2. **Templates module** (`src/lib/templates.ts`) - Node, Python, Go, Generic devcontainer templates
3. **Project module** (`src/lib/project.ts`) - Project resolution from cwd, listing local projects
4. **Up command** (`src/commands/up.ts`) - Full workflow with sync check, container management, editor preference
5. **Editor command** (`src/commands/editor.ts`) - Change default editor preference
6. **CLI registration** - Both commands added to main entry point

Total: 12 tasks, ~45 steps, following TDD approach throughout.

import { existsSync, readFileSync, writeFileSync } from "node:fs";
import { resolve } from "node:path";
import {
	COMMAND_MANIFEST,
	GLOBAL_OPTIONS,
	type CommandArgumentSpec,
	type CommandManifestEntry,
	type CommandOptionSpec,
} from "../src/lib/command-manifest.ts";

const COMMAND_SPEC_START = "<!-- COMMAND-SPEC:START -->";
const COMMAND_SPEC_END = "<!-- COMMAND-SPEC:END -->";

const repoRoot = resolve(import.meta.dir, "..");
const checkOnly = process.argv.includes("--check");

const toAbsolutePath = (relativePath: string): string => {
	return resolve(repoRoot, relativePath);
};

const escapeCell = (value: string): string => {
	return value.replaceAll("|", "\\|");
};

const renderArgumentsSection = (argumentsList: CommandArgumentSpec[]): string => {
	if (argumentsList.length === 0) {
		return "## Arguments\n\nNone.";
	}

	const rows = argumentsList
		.map((argument) => {
			return `| \`${escapeCell(argument.name)}\` | ${escapeCell(argument.description)} |`;
		})
		.join("\n");

	return [
		"## Arguments",
		"",
		"| Argument | Description |",
		"|----------|-------------|",
		rows,
	].join("\n");
};

const renderOptionsTable = (options: CommandOptionSpec[]): string => {
	if (options.length === 0) {
		return "None.";
	}

	const rows = options
		.map((option) => {
			const description = option.defaultValue
				? `${option.description} (default: ${option.defaultValue})`
				: option.description;
			return `| \`${escapeCell(option.flags)}\` | ${escapeCell(description)} |`;
		})
		.join("\n");

	return [
		"| Option | Description |",
		"|--------|-------------|",
		rows,
	].join("\n");
};

const renderGlobalOptionsTable = (): string => {
	const rows = GLOBAL_OPTIONS.map((option) => {
		return `| \`${escapeCell(option.flags)}\` | ${escapeCell(option.description)} |`;
	}).join("\n");

	return [
		"| Option | Description |",
		"|--------|-------------|",
		rows,
	].join("\n");
};

const renderGeneratedSections = (command: CommandManifestEntry): string => {
	const usageSection = ["## Usage", "", "```bash", command.usage, "```"].join("\n");
	const argumentsSection = renderArgumentsSection(command.arguments);
	const optionsSection = ["## Options", "", renderOptionsTable(command.options)].join(
		"\n",
	);
	const globalOptionsSection = [
		"## Global Options",
		"",
		renderGlobalOptionsTable(),
	].join("\n");

	return [
		COMMAND_SPEC_START,
		usageSection,
		"",
		argumentsSection,
		"",
		optionsSection,
		"",
		globalOptionsSection,
		COMMAND_SPEC_END,
	].join("\n");
};

const replaceExistingGeneratedBlock = (
	content: string,
	generatedBlock: string,
): string | null => {
	const startIndex = content.indexOf(COMMAND_SPEC_START);
	const endIndex = content.indexOf(COMMAND_SPEC_END);

	if (startIndex === -1 || endIndex === -1) {
		return null;
	}

	if (endIndex < startIndex) {
		throw new Error("Invalid command spec markers: end marker appears before start marker.");
	}

	const blockEndIndex = endIndex + COMMAND_SPEC_END.length;
	return `${content.slice(0, startIndex)}${generatedBlock}${content.slice(blockEndIndex)}`;
};

const replaceLegacyTopSections = (
	content: string,
	generatedBlock: string,
	docsFile: string,
): string => {
	const usageHeader = "## Usage";
	const descriptionHeader = "## Description";
	const usageIndex = content.indexOf(usageHeader);
	const descriptionIndex = content.indexOf(descriptionHeader);

	if (usageIndex === -1 || descriptionIndex === -1 || descriptionIndex <= usageIndex) {
		throw new Error(
			`Could not locate usage/description section boundaries in ${docsFile}`,
		);
	}

	return `${content.slice(0, usageIndex)}${generatedBlock}\n\n${content.slice(descriptionIndex)}`;
};

const syncCommandDoc = (
	command: CommandManifestEntry,
): { file: string; changed: boolean } => {
	const filePath = toAbsolutePath(command.docsFile);
	if (!existsSync(filePath)) {
		throw new Error(`Doc file not found: ${command.docsFile}`);
	}

	const before = readFileSync(filePath, "utf8");
	const generatedBlock = renderGeneratedSections(command);
	const replaced = replaceExistingGeneratedBlock(before, generatedBlock);
	const after = replaced ?? replaceLegacyTopSections(before, generatedBlock, command.docsFile);

	if (after !== before && !checkOnly) {
		writeFileSync(filePath, after, "utf8");
	}

	return {
		file: command.docsFile,
		changed: after !== before,
	};
};

const renderCommandsTs = (): string => {
	const rows = COMMAND_MANIFEST.map((command) => {
		return `  { text: ${JSON.stringify(command.docsText)}, link: ${JSON.stringify(command.docsPath)}, description: ${JSON.stringify(command.docsDescription)} },`;
	}).join("\n");

	return `/**
 * Single source of truth for the reference command list.
 * Used by both the sidebar (config.ts) and the commands overview page.
 *
 * THIS FILE IS AUTO-GENERATED by scripts/sync-command-reference.ts.
 * Do not edit manually.
 */
export interface CommandEntry {
  /** Display name, e.g. "skybox init" */
  text: string;
  /** Link path, e.g. "/reference/init" */
  link: string;
  /** Short description for the overview table */
  description: string;
}

export const commands: CommandEntry[] = [
${rows}
];
`;
};

const syncCommandsTs = (): { file: string; changed: boolean } => {
	const relativePath = "docs/.vitepress/commands.ts";
	const filePath = toAbsolutePath(relativePath);
	const before = existsSync(filePath) ? readFileSync(filePath, "utf8") : "";
	const after = renderCommandsTs();

	if (after !== before && !checkOnly) {
		writeFileSync(filePath, after, "utf8");
	}

	return {
		file: relativePath,
		changed: after !== before,
	};
};

const main = (): void => {
	const results = COMMAND_MANIFEST.map(syncCommandDoc);
	results.push(syncCommandsTs());

	const changed = results.filter((result) => result.changed);
	if (changed.length === 0) {
		console.log("Command reference is up to date.");
		return;
	}

	if (checkOnly) {
		console.error("Command reference is out of date:");
		for (const result of changed) {
			console.error(`  - ${result.file}`);
		}
		process.exit(1);
	}

	console.log("Updated command reference files:");
	for (const result of changed) {
		console.log(`  - ${result.file}`);
	}
};

main();
